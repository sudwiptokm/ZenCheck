import * as Calendar from "expo-calendar";

import { Alert } from "react-native";
import { TaskDTO } from "../models/task/TaskSchema";
import { createCalendar } from "./calender";
import moment from "moment";

export const capitalize = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

export const momentDateAndTimeToDateObject = (
  date: string,
  momentTime: string,
) => {
  const startDate = moment(date, "MMM Do YY").toDate();
  // Parse the time string generated by moment into a JavaScript Date object
  const time = moment(momentTime, "hh:mm A").toDate();

  // Get the year, month, and day from startDate
  const year = startDate.getFullYear();
  const month = startDate.getMonth();
  const day = startDate.getDate();

  // Get the hour and minute from time
  const hour = time.getHours();
  const minute = time.getMinutes();

  // Create a new Date object with the combined date and time
  return new Date(year, month, day, hour, minute);
};

export const addReminder = async (data: TaskDTO) => {
  try {
    const calendarId = await createCalendar();
    const start = momentDateAndTimeToDateObject(
      data.startDate!,
      data.startTime!,
    );
    const end = momentDateAndTimeToDateObject(data.endDate!, data.endTime!);

    await Calendar.createEventAsync(calendarId, {
      endDate: end,
      startDate: start,
      title: data.name,
      creationDate: new Date(),
      timeZone: "Asia/Dhaka",
      notes: data.description,
      alarms: [
        {
          relativeOffset: -10,
        },
      ],
    });
    Alert.alert("Reminder Set!");

    return calendarId;
  } catch (e) {
    console.log(e);
  }
};

export const removeReminder = async (calendarId: string) => {
  try {
    await Calendar.deleteCalendarAsync(calendarId);
    Alert.alert("Reminder Removed!");
  } catch (e) {
    console.log(e);
  }
};

export const sortTasksByPriority = (
  tasks: TaskDTO[],
  order: "asc" | "desc" = "asc",
) => {
  const priorityMap = { low: 0, medium: 1, high: 2 };

  return tasks.sort((task1, task2) => {
    const priority1 = priorityMap[task1.priority as keyof typeof priorityMap];
    const priority2 = priorityMap[task2.priority as keyof typeof priorityMap];

    if (order === "asc") {
      return priority1 - priority2;
    } else {
      return priority2 - priority1;
    }
  });
};

export const sortTasksByDate = (tasks: TaskDTO[], order = "asc") => {
  return tasks.sort((task1, task2) => {
    const date1 = new Date(task1.createdAt).getTime();
    const date2 = new Date(task2.createdAt).getTime();

    if (order === "asc") {
      return date1 - date2;
    } else {
      return date2 - date1;
    }
  });
};
